#version 150

uniform vec4 lightPos;
uniform vec4 lightColor;
uniform vec4 lightDir;

uniform mat4 viewMatrix;
uniform mat4 projMatrix;
uniform vec3 hitheryon;

uniform sampler2D shadowbuffer;
uniform sampler2D tex;

in vec2 v_texcoord;
in vec3 v_worldPos;
in vec3 v_normal;

out vec4 color;

//get world space point
//pe = worldSpacePoint*light_viewMatrix;
//ps = worldSpacePoint*light_projMatrix;
//do homogenous divide
//map results x,y from -1...1 range to 0...1 range. (call this tc)
//fetch texel from the shadowbuffer texture at tc, call it t
	//remap from 0...1 to hither...yon
//if (-pe.z < 0 or -pe.z > t+0.005)
	//{		shadowed	}
//else {	not shadowed	}

void main() {
	float bias = 1.0;
	vec4 pw;
	pw.xyz = v_worldPos;
	pw = pw * viewMatrix;
	float z1 = -pw.z;
	pw = pw * projMatrix;
	pw /= pw.w;	//homogenous divide
	pw = 0.5 * (pw + 1.0);

	vec3 N = normalize(v_normal);
	vec3 L = -lightDir.xyz;

	vec4 tmp = texture2D(shadowbuffer, pw.xy);
	float z2 = tmp.r;

	z2 = hitheryon[0] + z2 * hitheryon[2];

	float shadowfactor = 1.0;

	if(z1 > z2+bias || pw.z < 0.5 || any( lessThan(pw.xy, vec2(0.0,0.0))) || any (greaterThan(pw.xy,vec2(1.0,1.0)))) {
		//In shadow
		shadowfactor = 0.2;
	}

	float dp = clamp( dot(L, N), 0.0, 1.0);
	vec4 texc = texture2D(tex, v_texcoord.st);
	color.rgb = shadowfactor * dp * texc.rgb;// + !!!.rgb;
	color.a = 1.0;


}